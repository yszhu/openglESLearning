一、变量
1、变量方面提供了向量和矩阵作为基本类型
	1.1、标量
		folat int uint bool
	1.2、向量有四种类型，每种类型均提供1到四维，
		一维类型为标量类型，2维到4维有特定的格式（标量首字母vec维数），
		float为特殊的 float vec2 vec3 vec4，其余遵守以上规则
		以int为例，int ivec2 ivec3 ivec4

	1.3、矩阵为浮点矩阵,根据行列分为9种
		mat2(或者mat2x2) mat2x3           mat2x4
		mat3x2           mat3(或者mat3x3) mat3x4 
		mat4x2           mat4x3           mat4(或者mat4x4)
	1.4、向量的构造
		1)如果仅提供一个标量参数，则这个标量参数用于初始化向量的所有分量
		2)如果提供多个向量，则按顺序从左至右依次使用参数的分量来初始化所有分量
		3)如果使用多个标量，向量的维数不得低于参数的个数
	question1	4)向量和标量混用可以吗？
	1.5、矩阵的构造
		1)注意矩阵是列主序的，因此在应用程序和shader程序中的样式看起来可能稍有不同。
		2)如果只提供一个标量n，这个标量将被用于构造一个数量矩阵(对角线元素为n的对角阵)
		3)如果参数足够，矩阵可以通过向量、标量之间的任何组合形式构造
2、类型转换
	gles的类型规定严格，不允许隐式转换，只能通过构造器显示转换
	float myFloat=1.0 //ok
	float myFloat =1  //wrong
	float myFlaot=flaot(1) //ok again
3、向量和矩阵的访问
	1)矩阵的每一列都是一个向量
	2)向量的访问有两种方式
	①[]下标式，像访问数组一样，通过此方式访问矩阵获得列向量
	②.式，像使用对象的属性一样，.式访问有三套系统，三套系统间不可混用(如myVec3.zxb)
	{x,y,z,w},{r,g,b,a},{s,t,p,q},通过.式访问可以获取一个向量 如：
	(myVec3.x 一维,一维可用作标量)，(myVec3.xy 二维)
4、常量的声明
	1)可以声明任何基本类型的常量，在类型前加const 关键字,代表不可修改
	2）常量声明时一定要初始化。
5、结构和数组和C语言相似
  	1)它们都是用构造器初始化如：
  	strut fogStruct{
	  	ver4 color;
	  	float start;
	  	float end;
  	} fogVar;
  	fogVar=fogStruct(vec4(0.0,1.0,0.0,0.,),//color
  						0.5,			   //start
  						2.0)			   //end

  	float a[4]=flaot[](1.0,2.0,3.0,4.0);
  	float b[4]=float[4](1.0,2.0,3.0,4.0);
  	vec2 c[2]=vec[2](vec2(1.0),vec2(1.0));
6、总结
	1)除标量外，变量均适用构造器初始化
	2)类型转换使用构造器转换
	3)向量和矩阵的构造都可以解析向量参数
	4)向量和标量的访问均有2中形式，.式访问可以得到向量，三套系统不可混用

二、函数
	1)函数不能递归
	2)参数有参数限定符决定这些参数如何使用(模拟值传递和引用传递，若修改了某一变量，在函数返回后才会生效)
	3)参数限定符有三种
	①in 参数按值传递，不能修改(默认的限定符)
	②inout 引用传递
	③out 改参数值不可用，但可以修改该参数
	4)glsl提供了许多强大便捷的内建函数，包括计算向量点积，标量幂次等，可以方便地操作矩阵，向量等。

三、统一变量块儿
	1)统一变量块儿可以在程序对象之间共享
	2)统一变量块儿的生命方式如下
	uniform TransformBlock{
		mat4 matViewPooj;
		mat3 matNormal;
		mat3 matTexGen;
	}
	3)在缓冲区对象之间切换比单独加载一个统一变量效率更高
question2 4)统一变量缓冲区对象的细节？第四章

	5)可以使用布局限定符指定统一变量块儿在内存中的布局方式，用法如下:
	layout(shared,column_major) uniform;
	6)统一变量块儿中的统一变量也可以指定布局限定符
	layout(stdl40) uniform TransformBlock{
		mat4 matViewProj;
		layout(row_major) mat matNormal;
		mat3 matTexGen;
	};
	7)布局限定符
	①shared 指定多个着色器或多个程序对象的统一变量块儿内存布局相同，要求不同定义中的
	row_major/column_major值必须相等。覆盖stdl40和packed
	②packed （默认）指定编译器可以优化统一变量块儿布局，使用这个限定符必须查询偏移位置，统一变量块儿无法再顶点/片段着色器或者程序对象间共享覆盖stdl40和shared
	③stdl40遵循基于OpenGL ES3.0规范的“标准统一变量布局，覆盖shared和packed
	④row_major矩阵在内存中行主序
	⑤column_major矩阵在内存中列主序
	8)布局限定符可以为顶点输入变量指定索引
四、顶点和片段着色器输入/输出限定符
	1)顶点位置，a_position 颜色a_color 等相关的从应用程序传递的数据需要使用输入限定符
	2)顶点着色器和片段着色器之前传递的变量(非同一变量)一需要使用输出/输入限定符修饰,二者除输入/输出限定符(顶点着色器的为输出 out ，片段着色器的为输入in)不同外，其余全部相同
	3)片段着色器中需要输出到帧缓冲区的数据也需要使用输出限定符 out
	4)片段着色器中的输入变量(顶点着色器的输出变量)不能使用布局限定符
五、插值限定符
   1)顶点着色器的输出变量(片段着色器中的输入变量)没有指定产值限定符是默认使用平滑着色
   smooth，
   2)插值行文可以明确请求
   v shader
   smooth out vec3 v_color

   f shader
   smooth in vec3 v_color
   3)还有一种平面着色(flat)
   4)还可以使用centroid关键字在插值器中添加另一个限定符。质心采取，可以强制在图元内部
   也进行产值，防止边缘出现伪像。
   5)顶点输出/片段输入 变量通常称为插值器
六、glse的预处理
	1)不能使用参数(即不能定义函数宏)
	2)可以启用扩展,不同供应商对glsl的扩展

七、不变性
	1)着色器编译前可能会对着色器代码进行优化，精度的差异等可能会导致
	输出的结果不同。限制不变性，可以保证相同的输入得到相同的输出。
	invariant gl_Position
八、着色器中变量
	1)in修饰的变量只能是基本变量,而且是只读的，不能修改,不然会有编译错误
	2)顶点属性的数量有限制，超过GL_MAX_VERTEX_ATTRIBS,这个顶点着色器就无法链接,
	除了数量,顶点着色器中顶点属性是否使用很重要,仅被声明而未被使用的被视为不活动的变量,
	不活动的变量编译时通常会被优化掉(默认如此，可以指定不优化掉),OpenGL ES3.0提供了
	很多查询着色器中变量的方法，但一般都是查询活动变量的,因此着色器中声明的变量有可能在应用程序中查找不到,无法引用
	3)顶点属性索引和着色器中的顶点属性绑定有三总方式
	①使用layout(location=N)指定，最直接
	②OpenGL ES3.0将通用顶点属性索引绑定到属性名称(glBindAttribLocation),
	这种方式下一次链接时生效,甚至可以在链接之前调用，即使是指定不存在或不活动的变量(
	这种状况下，那些变量将被忽略)
	③应用程序中将顶点属性绑定到属性名称

